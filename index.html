<!DOCTYPE html>
<html lang="ar">

<head>
  <meta charset="utf-8" />
  <title>Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹ Ø§Ù„Ø§Ø³ØªØ«Ù…Ø§Ø±ÙŠØ©</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Tajawal&display=swap">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.control.layers.tree/L.Control.Layers.Tree.css" />
  <link rel="stylesheet" href="style/style.css" />
</head>

<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.control.layers.tree/L.Control.Layers.Tree.js"></script>

  <div id="map-controls">
    <button id="toggleLayers" class="toggle-button" title="Ø¥Ø¸Ù‡Ø§Ø±/Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø·Ø¨Ù‚Ø§Øª"></button>
    <button class="basemap-button" onclick="setBaseMap('Hybrid')" title="Ù‚Ù…Ø± ØµÙ†Ø§Ø¹ÙŠ Ø¨Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…ÙƒØ§Ù†ÙŠØ©">ğŸ›°ï¸</button>
    <button class="basemap-button" onclick="setBaseMap('Satellite')" title="Ù‚Ù…Ø± ØµÙ†Ø§Ø¹ÙŠ">ğŸ›°ï¸</button>
    <button class="basemap-button" onclick="setBaseMap('Road')" title="Ø®Ø±ÙŠØ·Ø© Ø¨Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø´ÙˆØ§Ø±Ø¹">ğŸ—ºï¸</button>
    <input type="text" id="filterInput" placeholder="ğŸ” Ø§ÙƒØªØ¨ Ù†Øµ Ø§Ù„ÙÙ„ØªØ±Ø©" title="Ø§ÙƒØªØ¨ Ù„Ù„Ø¨Ø­Ø« Ø¯Ø§Ø®Ù„ Ø§Ù„Ø·Ø¨Ù‚Ø§Øª" />
    <span id="filter-status" style="display: none;">
      <button id="match-count">0</button>
      <button id="prev-match" title="Ø§Ù„Ø³Ø§Ø¨Ù‚">â¡ï¸</button>
      <button id="next-match" title="Ø§Ù„ØªØ§Ù„ÙŠ">â¬…ï¸</button>
    </span>
    <button id="clearFilter" title="Ù…Ø³Ø­ Ø§Ù„ÙÙ„ØªØ±Ø©">âŒ</button>
  </div>
  </div>

  <div id="map"></div>

  <script>
    let matchedLayers = [];
    let currentMatchIndex = -1;
    let filterTimeout = null;

    const filterInput = document.getElementById("filterInput");
    const clearFilterBtn = document.getElementById("clearFilter");
    const matchCountSpan = document.getElementById("match-count");
    const filterStatus = document.getElementById("filter-status");
    const nextBtn = document.getElementById("next-match");
    const prevBtn = document.getElementById("prev-match");

    const viewerPath = 'https://aleppo-gis.github.io/v/v.html';

    // Ù…ÙØªØ§Ø­ API Ù…Ù† TinyURL (Ø¶Ø¹ Ù…ÙØªØ§Ø­Ùƒ Ù‡Ù†Ø§)
    const TINYURL_API_KEY = "xBSvW6XqO3Tdng0dhybh6VEdyiXs488gsm20nVthZoApV45x8MnsKUTDFKh3";

    // Ø¶ØºØ· GeoJSON
    function compressGeoJSON(obj) {
      return LZString.compressToEncodedURIComponent(JSON.stringify(obj));
    }

    // Ø¥ÙŠØ¬Ø§Ø¯ Ø§Ù„Ø·Ø¨Ù‚Ø© Ø¨Ø§Ù„Ø§Ø³Ù…
    function findLayerByAlias(alias) {
      let found = null;
      if (!Array.isArray(allLayerGroups)) return null;
      allLayerGroups.forEach(({ group }) => {
        if (found) return;
        group.eachLayer(layer => {
          if (found) return;
          const feat = layer.feature || {};
          const props = feat.properties || {};
          const aliasName = props.Name || props.name || props['Ø§Ù„Ø§Ø³Ù…'] || layer.options?.name;
          if (aliasName === alias) found = layer;
        });
      });
      return found;
    }

    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¶Ù„Ø¹ Ø£Ùˆ Ù…Ø±Ø¨Ø¹ Ø­ÙˆÙ„ Ù†Ù‚Ø·Ø©
    function extractPolygonCoordinates(layer) {
      if (typeof layer.getLatLngs === 'function') {
        const latlngsRaw = layer.getLatLngs();
        let ring = null;
        if (Array.isArray(latlngsRaw) && latlngsRaw.length) {
          if (Array.isArray(latlngsRaw[0]) && latlngsRaw[0][0] && typeof latlngsRaw[0][0].lat === 'number') ring = latlngsRaw[0];
          else if (latlngsRaw[0] && typeof latlngsRaw[0].lat === 'number') ring = latlngsRaw;
        }
        if (ring && ring.length >= 3) {
          const coords = ring.map(p => [p.lng, p.lat]);
          const first = coords[0], last = coords[coords.length - 1];
          if (!first || !last || first[0] !== last[0] || first[1] !== last[1]) coords.push([first[0], first[1]]);
          return coords;
        }
      }
      if (typeof layer.getLatLng === 'function') {
        const p = layer.getLatLng();
        const offset = 0.0008;
        return [
          [p.lng - offset, p.lat - offset],
          [p.lng + offset, p.lat - offset],
          [p.lng + offset, p.lat + offset],
          [p.lng - offset, p.lat + offset],
          [p.lng - offset, p.lat - offset]
        ];
      }
      return null;
    }

    // Ø®ØµØ§Ø¦Øµ Ù…Ø±Ø¦ÙŠØ© ÙÙ‚Ø· (Alias ÙƒÙ…ÙØ§ØªÙŠØ­)
    function buildVisiblePropsOnly(layer) {
      const feat = layer.feature || {};
      const props = feat.properties || {};
      const visible = props.__visible_fields__;
      const result = {};

      if (Array.isArray(visible) && visible.length > 0) {
        visible.forEach(item => {
          if (!item || !item.name) return;
          const key = String(item.name);
          if (!(key in props)) return;
          const alias = (item.alias && String(item.alias)) || key;
          result[alias] = props[key];
        });
        return result;
      }

      Object.keys(props).forEach(k => {
        if (k.startsWith('_')) return;
        result[k] = props[k];
      });
      return result;
    }

    // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ TinyURL API Ù„ØªÙ‚ØµÙŠØ± Ø§Ù„Ø±Ø§Ø¨Ø·
    async function shortenUrl(longUrl) {
      const res = await fetch("https://api.tinyurl.com/create", {
        method: "POST",
        headers: {
          "Authorization": "Bearer " + TINYURL_API_KEY,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ url: longUrl })
      });
      if (!res.ok) throw new Error("TinyURL API error");
      const data = await res.json();
      return data.data.tiny_url;
    }

    // ÙƒØ´Ù Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¹Ù„Ù‰ Ù…ÙˆØ¨Ø§ÙŠÙ„
    function isMobile() {
      return /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    }

    // Ø­Ø¯Ø« Ø²Ø± Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©
    document.addEventListener('click', async function (e) {
      const target = e.target;
      if (!target || target.id !== 'share') return;
      const layerAlias = target.dataset.layerName;
      if (!layerAlias) return;
      e.preventDefault();

      const layer = findLayerByAlias(layerAlias);
      if (!layer) { alert('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø·Ø¨Ù‚Ø©'); return; }

      const coords = extractPolygonCoordinates(layer);
      if (!coords || coords.length < 4) { alert('ØªØ¹Ø°Ø± Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¶Ù„Ø¹ ØµØ§Ù„Ø­ Ù…Ù† Ø§Ù„Ø·Ø¨Ù‚Ø©'); return; }

      const visibleProps = buildVisiblePropsOnly(layer);
      if (!visibleProps || Object.keys(visibleProps).length === 0) {
        visibleProps['Ø§Ù„Ø§Ø³Ù…'] = layerAlias;
      }

      const geojson = {
        type: 'FeatureCollection',
        features: [{
          type: 'Feature',
          geometry: { type: 'Polygon', coordinates: [coords] },
          properties: visibleProps
        }]
      };

      const compressed = compressGeoJSON(geojson);
      const longUrl = viewerPath + '?data=' + encodeURIComponent(compressed);

      try {
        const shortUrl = await shortenUrl(longUrl);
        const message = `Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ : ${layerAlias}\n${shortUrl}`;
        const whatsappUrl = (isMobile() ? 'whatsapp://send?text=' : 'https://wa.me/?text=')
          + encodeURIComponent(message);
        window.location.href = whatsappUrl;
      } catch (err) {
        console.error(err);
        // fallback Ù„Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ø£ØµÙ„ÙŠ
        const message = `Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ : ${layerAlias}\n${longUrl}`;
        const whatsappUrl = (isMobile() ? 'whatsapp://send?text=' : 'https://wa.me/?text=')
          + encodeURIComponent(message);
        window.location.href = whatsappUrl;
      }
    });


    function normalizeText(text) {
      return text
        .toLowerCase()
        .replace(/[Ø¥Ø£Ø¢Ø§]/g, "Ø§")
        .replace(/Ù‰/g, "ÙŠ")
        .replace(/Ø¤/g, "Ùˆ")
        .replace(/Ø¦/g, "ÙŠ")
        .replace(/Ø©/g, "Ù‡")
        .replace(/[Ù‹ÙŒÙÙÙÙÙ’Ù‘]/g, "") // Ø­Ø°Ù Ø§Ù„ØªØ´ÙƒÙŠÙ„
        .trim();
    }

    const map = L.map("map", { preferCanvas: true });
    const allLayerGroups = [];
    //"Esri": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'),

    const baseMaps = {
      "Hybrid": L.tileLayer('https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}'),
      "Satellite": L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}'),
      "Road": L.tileLayer('https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}')
    };
    let currentBaseMap = baseMaps["Hybrid"];

    document.getElementById("toggleLayers").addEventListener("click", () => {
      const panel = document.querySelector(".leaflet-control-layers");
      if (panel) {
        panel.style.display = (panel.style.display === "none") ? "flex" : "none";
      }
    });

    function setBaseMap(name) {
      if (currentBaseMap) map.removeLayer(currentBaseMap);
      currentBaseMap = baseMaps[name];
      map.addLayer(currentBaseMap);
    }

    fetch("data/geojson_grouped.json")
      .then(res => res.json())
      .then(data => {
        const allBounds = L.latLngBounds();
        const treeGroups = [];

        for (let gid in data) {
          const group = data[gid];
          const groupName = group.__group_name__ || gid;
          const groupStyles = group.__styles__ || {};
          const children = [];

          for (let layerName in group) {
            if (layerName.startsWith("__")) continue;
            const fc = group[layerName];
            const style = groupStyles[layerName] || {};

            let mapLink = null;
            if (fc.features && fc.features.length > 0) {
              const props = fc.features[0].properties || {};
              if (typeof props.MapLink === "string") {
                const raw = props.MapLink.trim();
                const cleaned = raw.replace(/^["']|["']$/g, "");
                if (/^\d+\/-?\d+(\.\d+)?\/-?\d+(\.\d+)?$/.test(cleaned)) {
                  mapLink = cleaned;
                }
              }
            }

            const zoomCoords = mapLink ? mapLink.split("/") : null;
            const zoom = zoomCoords ? parseInt(zoomCoords[0]) : null;
            const lat = zoomCoords ? parseFloat(zoomCoords[1]) : null;
            const lng = zoomCoords ? parseFloat(zoomCoords[2]) : null;

            const jumpIcon = (zoom && lat && lng)
            const labelHtml = `
              <span class='layer-color-box' style='background-color:${style.fillColor || style.color || "#3388ff"};opacity:${style.fillOpacity || 0.6};'></span>
              <button data-zoom='${zoom}' data-lat='${lat}' data-lng='${lng}' class='layer-name'>${layerName}</button>
              <button class="fa-brands fa-whatsapp" id='share' style='cursor: pointer; background-color:#ffffff; border:0;' data-layer-name='${layerName}' data-zoom='${zoom}' data-lat='${lat}' data-lng='${lng}'></button>
            `;

            const layerGroup = L.featureGroup();
            const geoJsonLayer = L.geoJSON(fc, {
              style: () => style,
              pointToLayer: (feature, latlng) => {
                const opts = {
                  radius: style.radius || 6,
                  fillColor: style.fillColor || style.color || "#3388ff",
                  color: style.color || "#333333",
                  weight: style.weight || 1,
                  fillOpacity: style.fillOpacity || 0.6
                };
                return L.circleMarker(latlng, opts);
              },
              onEachFeature: (feature, layerObj) => {
                const props = feature.properties || {};
                let rows = "";
                let rowsAdded = 0;
                const visible = props.__visible_fields__;

                if (Array.isArray(visible) && visible.length > 0) {
                  visible.forEach(f => {
                    const key = f.name;
                    const alias = f.alias || key;
                    const value = props[key];
                    if (value !== null && value !== undefined && value !== "") {
                      rows += `<tr><td class='popup-key'><b>${alias}</b></td><td class='popup-value'>${value}</td></tr>`;
                      rowsAdded++;
                    }
                  });
                } else {
                  for (let key in props) {
                    if (key.startsWith("__")) continue;
                    const value = props[key];
                    if (value !== null && value !== undefined && value !== "") {
                      rows += `<tr><td class='popup-key'><b>${key}</b></td><td class='popup-value'>${value}</td></tr>`;
                      rowsAdded++;
                    }
                  }
                }

                if (rowsAdded > 0) {
                  const popup = `<table class='popup-table'>${rows}</table>`;
                  layerObj.bindPopup(popup);
                }

                let markerLatLng = null;
                if (feature.geometry.type === "Point") {
                  markerLatLng = layerObj.getLatLng();
                } else {
                  try {
                    markerLatLng = layerObj.getBounds().getCenter();
                  } catch (e) {
                    markerLatLng = null;
                  }
                }

                if (markerLatLng) {
                  const icon = L.icon({
                    iconUrl: 'img/marker.png',
                    iconSize: [48, 48],
                    iconAnchor: [24, 48],
                    className: 'marker-with-shadow'
                  });
                  const marker = L.marker(markerLatLng, { icon });
                  marker.bindPopup(layerObj.getPopup());
                  marker.bindTooltip(layerName, {
                    permanent: false,
                    direction: 'top',
                    sticky: true,
                    className: 'marker-tooltip'
                  });
                  layerGroup.addLayer(marker);
                }

                layerGroup.addLayer(layerObj);
              }
            });

            layerGroup.addLayer(geoJsonLayer);
            layerGroup.addTo(map);
            const bounds = layerGroup.getBounds();
            if (bounds && bounds.isValid()) {
              allBounds.extend(bounds);
            }

            children.push({ label: labelHtml, layer: layerGroup });
            let keywords = normalizeText(layerName);

            if (fc.features && fc.features.length > 0) {
              fc.features.forEach(f => {
                const props = f.properties || {};
                for (let key in props) {
                  const val = props[key];
                  if (typeof val === "string") {
                    keywords += " " + normalizeText(val);
                  }
                }
              });
            }
            allLayerGroups.push({ keywords, group: layerGroup });
          }

          const groupLabel = `<b>${groupName} (${children.length})</b>`;

          treeGroups.push({
            label: groupLabel,
            selectAllCheckbox: true,
            children: children,
            collapsed: true
          });
        }

        if (allBounds.isValid()) {
          map.fitBounds(allBounds);
        } else {
        }

        if (!map.hasLayer(currentBaseMap)) {
          currentBaseMap.addTo(map);
        }

        const control = L.control.layers.tree(null, treeGroups, {
          collapsed: false,
          position: "topright"
        }).addTo(map);

        document.querySelector(".leaflet-control-layers").addEventListener("click", e => {
          const icon = e.target.closest(".jump-icon");
          if (icon) {
            e.preventDefault();
            e.stopPropagation();
            const zoom = parseInt(icon.dataset.zoom);
            const lat = parseFloat(icon.dataset.lat);
            const lng = parseFloat(icon.dataset.lng);
            if (!isNaN(zoom) && !isNaN(lat) && !isNaN(lng)) {
              map.setView([lat, lng], zoom);
            }
          }
        });
      });

    filterInput.addEventListener("input", () => {
      clearTimeout(filterTimeout);
      filterTimeout = setTimeout(() => {
        const text = normalizeText(filterInput.value);
        matchedLayers = [];
        currentMatchIndex = -1;

        const seenNames = new Set();

        // 1. Ø§Ø¬Ù…Ø¹ Ø§Ù„Ø·Ø¨Ù‚Ø§Øª Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø© ÙÙ‚Ø·
        allLayerGroups.forEach(({ group }) => {
          group.eachLayer(layer => {
            const props = layer.feature?.properties;
            const hasZoom = layer.getBounds || layer.getLatLng;

            let match = false;
            if (props) {
              for (const key in props) {
                const value = props[key];
                if (typeof value === "string" && normalizeText(value).includes(text)) {
                  match = true;
                  break;
                }
              }
            }

            if (match) {
              const name = props?.name?.trim() || `${layer._leaflet_id}`;
              if (hasZoom && !seenNames.has(name)) {
                matchedLayers.push(layer);
                seenNames.add(name);
              }
            }
          });
        });

        // 2. Ø£Ø®ÙÙ ÙƒÙ„ Ø§Ù„Ø·Ø¨Ù‚Ø§Øª
        allLayerGroups.forEach(({ group }) => {
          group.eachLayer(layer => {
            if (map.hasLayer(layer)) map.removeLayer(layer);
          });
        });

        // 3. Ø£Ø¸Ù‡Ø± ÙÙ‚Ø· Ø§Ù„Ø·Ø¨Ù‚Ø§Øª Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø©
        matchedLayers.forEach(layer => {
          if (!map.hasLayer(layer)) {
            map.addLayer(layer);
          }
        });

        // 4. ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
        matchCountSpan.textContent = matchedLayers.length;
        filterStatus.style.display = matchedLayers.length > 0 ? "flex" : "none";

        if (matchedLayers.length > 0) {
          currentMatchIndex = 0;
          zoomToMatch(currentMatchIndex);
        }
      }, 500);
    });

    clearFilterBtn.addEventListener("click", () => {
      filterInput.value = "";
      filterStatus.style.display = "none";
      matchedLayers = [];
      currentMatchIndex = -1;

      allLayerGroups.forEach(({ group }) => {
        group.eachLayer(layer => {
          if (!map.hasLayer(layer)) map.addLayer(layer);
        });
      });
    });

    function zoomToMatch(index) {
      const layer = matchedLayers[index];
      if (!layer) return;

      try {
        if (layer.getBounds) {
          map.fitBounds(layer.getBounds(), { maxZoom: 19 });
        } else if (layer.getLatLng) {
          map.setView(layer.getLatLng(), 17);
        }
      } catch (e) {
        console.warn("ØªØ¹Ø°Ø± Ø§Ù„ØªÙƒØ¨ÙŠØ±:", e);
      }
    }

    nextBtn.addEventListener("click", () => {
      if (matchedLayers.length === 0) return;
      currentMatchIndex = (currentMatchIndex + 1) % matchedLayers.length;
      zoomToMatch(currentMatchIndex);
    });

    prevBtn.addEventListener("click", () => {
      if (matchedLayers.length === 0) return;
      currentMatchIndex = (currentMatchIndex - 1 + matchedLayers.length) % matchedLayers.length;
      zoomToMatch(currentMatchIndex);
    });

    document.addEventListener("click", function (e) {
      const target = e.target;
      if (target.matches("button[data-lat][data-lng][data-zoom]")) {

        const lat = parseFloat(target.getAttribute("data-lat"));
        const lng = parseFloat(target.getAttribute("data-lng"));
        const zoom = parseInt(target.getAttribute("data-zoom"));

        if (!isNaN(lat) && !isNaN(lng) && !isNaN(zoom)) {
          map.setView([lat, lng], zoom);
        }
      }
    });

  </script>
</body>

</html>