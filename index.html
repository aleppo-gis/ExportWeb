<!DOCTYPE html>
<html lang="ar">

<head>
  <meta charset="utf-8" />
  <title>ÿÆÿ±Ÿäÿ∑ÿ© ÿßŸÑŸÖÿ¥ÿßÿ±Ÿäÿπ ÿßŸÑÿßÿ≥ÿ™ÿ´ŸÖÿßÿ±Ÿäÿ©</title>
  <link href="https://fonts.googleapis.com/css2?family=Tajawal&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.control.layers.tree/L.Control.Layers.Tree.css" />
  <link rel="stylesheet" href="style/style.css" />
</head>

<body>
  <div id="map-controls">
    <button id="toggleLayers" class="toggle-button" title="ÿ•ÿ∏Ÿáÿßÿ±/ÿ•ÿÆŸÅÿßÿ° ÿßŸÑÿ∑ÿ®ŸÇÿßÿ™"></button>
    <button class="basemap-button" onclick="setBaseMap('Hybrid')" title="ŸÇŸÖÿ± ÿµŸÜÿßÿπŸä ÿ®ŸÖÿπŸÑŸàŸÖÿßÿ™ ŸÖŸÉÿßŸÜŸäÿ©">üõ∞Ô∏è</button>
    <button class="basemap-button" onclick="setBaseMap('Satellite')" title="ŸÇŸÖÿ± ÿµŸÜÿßÿπŸä">üõ∞Ô∏è</button>
    <button class="basemap-button" onclick="setBaseMap('Road')" title="ÿÆÿ±Ÿäÿ∑ÿ© ÿ®ÿ£ÿ≥ŸÖÿßÿ° ÿßŸÑÿ¥Ÿàÿßÿ±ÿπ">üó∫Ô∏è</button>
    <input type="text" id="filterInput" placeholder="üîç ÿßŸÉÿ™ÿ® ŸÜÿµ ÿßŸÑŸÅŸÑÿ™ÿ±ÿ©" title="ÿßŸÉÿ™ÿ® ŸÑŸÑÿ®ÿ≠ÿ´ ÿØÿßÿÆŸÑ ÿßŸÑÿ∑ÿ®ŸÇÿßÿ™" />
    <span id="filter-status" style="display: none;">
      <button id="match-count">0</button>
      <button id="prev-match" title="ÿßŸÑÿ≥ÿßÿ®ŸÇ">‚û°Ô∏è</button>
      <button id="next-match" title="ÿßŸÑÿ™ÿßŸÑŸä">‚¨ÖÔ∏è</button>
    </span>
    <button id="clearFilter" title="ŸÖÿ≥ÿ≠ ÿßŸÑŸÅŸÑÿ™ÿ±ÿ©">‚ùå</button>
  </div>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.control.layers.tree/L.Control.Layers.Tree.js"></script>

  <script>
    let matchedLayers = [];
    let currentMatchIndex = -1;
    let filterTimeout = null;

    const filterInput = document.getElementById("filterInput");
    const clearFilterBtn = document.getElementById("clearFilter");
    const matchCountSpan = document.getElementById("match-count");
    const filterStatus = document.getElementById("filter-status");
    const nextBtn = document.getElementById("next-match");
    const prevBtn = document.getElementById("prev-match");

    function normalizeText(text) {
      return text
        .toLowerCase()
        .replace(/[ÿ•ÿ£ÿ¢ÿß]/g, "ÿß")
        .replace(/Ÿâ/g, "Ÿä")
        .replace(/ÿ§/g, "Ÿà")
        .replace(/ÿ¶/g, "Ÿä")
        .replace(/ÿ©/g, "Ÿá")
        .replace(/[ŸãŸåŸçŸéŸèŸêŸíŸë]/g, "") // ÿ≠ÿ∞ŸÅ ÿßŸÑÿ™ÿ¥ŸÉŸäŸÑ
        .trim();
    }

    const map = L.map("map", { preferCanvas: true });
    const allLayerGroups = [];
    //"Esri": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'),

    const baseMaps = {
      "Hybrid": L.tileLayer('https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}'),
      "Satellite": L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}'),
      "Road": L.tileLayer('https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}')
    };
    let currentBaseMap = baseMaps["Hybrid"];

    document.getElementById("toggleLayers").addEventListener("click", () => {
      const panel = document.querySelector(".leaflet-control-layers");
      if (panel) {
        panel.style.display = (panel.style.display === "none") ? "flex" : "none";
      }
    });

    function setBaseMap(name) {
      if (currentBaseMap) map.removeLayer(currentBaseMap);
      currentBaseMap = baseMaps[name];
      map.addLayer(currentBaseMap);
    }

    fetch("data/geojson_grouped.json")
      .then(res => res.json())
      .then(data => {
        const allBounds = L.latLngBounds();
        const treeGroups = [];

        for (let gid in data) {
          const group = data[gid];
          const groupName = group.__group_name__ || gid;
          const groupStyles = group.__styles__ || {};
          const children = [];

          for (let layerName in group) {
            if (layerName.startsWith("__")) continue;
            const fc = group[layerName];
            const style = groupStyles[layerName] || {};

            let mapLink = null;
            if (fc.features && fc.features.length > 0) {
              const props = fc.features[0].properties || {};
              if (typeof props.MapLink === "string") {
                const raw = props.MapLink.trim();
                const cleaned = raw.replace(/^["']|["']$/g, "");
                if (/^\d+\/-?\d+(\.\d+)?\/-?\d+(\.\d+)?$/.test(cleaned)) {
                  mapLink = cleaned;
                }
              }
            }

            const zoomCoords = mapLink ? mapLink.split("/") : null;
            const zoom = zoomCoords ? parseInt(zoomCoords[0]) : null;
            const lat = zoomCoords ? parseFloat(zoomCoords[1]) : null;
            const lng = zoomCoords ? parseFloat(zoomCoords[2]) : null;

            const jumpIcon = (zoom && lat && lng)
              ? `<button title='ÿßŸÑÿ∞Ÿáÿßÿ® ÿ•ŸÑŸâ ÿßŸÑŸÖŸàŸÇÿπ' data-zoom='${zoom}' data-lat='${lat}' data-lng='${lng}'>...</button>`
              : "";

            const labelHtml = `
              <span class='layer-color-box' style='background-color:${style.fillColor || style.color || "#3388ff"};opacity:${style.fillOpacity || 0.6};'></span>
              <span class='layer-name'>${layerName}</span>
              ${jumpIcon}
            `;

            const layerGroup = L.featureGroup();
            const geoJsonLayer = L.geoJSON(fc, {
              style: () => style,
              pointToLayer: (feature, latlng) => {
                const opts = {
                  radius: style.radius || 6,
                  fillColor: style.fillColor || style.color || "#3388ff",
                  color: style.color || "#333333",
                  weight: style.weight || 1,
                  fillOpacity: style.fillOpacity || 0.6
                };
                return L.circleMarker(latlng, opts);
              },
              onEachFeature: (feature, layerObj) => {
                const props = feature.properties || {};
                let rows = "";
                let rowsAdded = 0;
                const visible = props.__visible_fields__;

                if (Array.isArray(visible) && visible.length > 0) {
                  visible.forEach(f => {
                    const key = f.name;
                    const alias = f.alias || key;
                    const value = props[key];
                    if (value !== null && value !== undefined && value !== "") {
                      rows += `<tr><td class='popup-key'><b>${alias}</b></td><td class='popup-value'>${value}</td></tr>`;
                      rowsAdded++;
                    }
                  });
                } else {
                  for (let key in props) {
                    if (key.startsWith("__")) continue;
                    const value = props[key];
                    if (value !== null && value !== undefined && value !== "") {
                      rows += `<tr><td class='popup-key'><b>${key}</b></td><td class='popup-value'>${value}</td></tr>`;
                      rowsAdded++;
                    }
                  }
                }

                if (rowsAdded > 0) {
                  const popup = `<table class='popup-table'>${rows}</table>`;
                  layerObj.bindPopup(popup);
                }

                let markerLatLng = null;
                if (feature.geometry.type === "Point") {
                  markerLatLng = layerObj.getLatLng();
                } else {
                  try {
                    markerLatLng = layerObj.getBounds().getCenter();
                  } catch (e) {
                    markerLatLng = null;
                  }
                }

                if (markerLatLng) {
                  const icon = L.icon({
                    iconUrl: 'img/marker.png',
                    iconSize: [48, 48],
                    iconAnchor: [24, 48],
                    className: 'marker-with-shadow'
                  });
                  const marker = L.marker(markerLatLng, { icon });
                  marker.bindPopup(layerObj.getPopup());
                  marker.bindTooltip(layerName, {
                    permanent: false,
                    direction: 'top',
                    sticky: true,
                    className: 'marker-tooltip'
                  });
                  layerGroup.addLayer(marker);
                }

                layerGroup.addLayer(layerObj);
              }
            });

            layerGroup.addLayer(geoJsonLayer);
            layerGroup.addTo(map);
            const bounds = layerGroup.getBounds();
            if (bounds && bounds.isValid()) {
              allBounds.extend(bounds);
            }

            children.push({ label: labelHtml, layer: layerGroup });
            let keywords = normalizeText(layerName);

            if (fc.features && fc.features.length > 0) {
              fc.features.forEach(f => {
                const props = f.properties || {};
                for (let key in props) {
                  const val = props[key];
                  if (typeof val === "string") {
                    keywords += " " + normalizeText(val);
                  }
                }
              });
            }
            allLayerGroups.push({ keywords, group: layerGroup });
          }

          const groupLabel = `<b>${groupName} (${children.length})</b>`;

          treeGroups.push({
            label: groupLabel,
            selectAllCheckbox: true,
            children: children,
            collapsed: true
          });
        }

        if (allBounds.isValid()) {
          map.fitBounds(allBounds);
        } else {
        }

        if (!map.hasLayer(currentBaseMap)) {
          currentBaseMap.addTo(map);
        }

        const control = L.control.layers.tree(null, treeGroups, {
          collapsed: false,
          position: "topright"
        }).addTo(map);

        document.querySelector(".leaflet-control-layers").addEventListener("click", e => {
          const icon = e.target.closest(".jump-icon");
          if (icon) {
            e.preventDefault();
            e.stopPropagation();
            const zoom = parseInt(icon.dataset.zoom);
            const lat = parseFloat(icon.dataset.lat);
            const lng = parseFloat(icon.dataset.lng);
            if (!isNaN(zoom) && !isNaN(lat) && !isNaN(lng)) {
              map.setView([lat, lng], zoom);
            }
          }
        });
      });

    filterInput.addEventListener("input", () => {
      clearTimeout(filterTimeout);
      filterTimeout = setTimeout(() => {
        const text = normalizeText(filterInput.value);
        matchedLayers = [];
        currentMatchIndex = -1;

        const seenNames = new Set();

        // 1. ÿßÿ¨ŸÖÿπ ÿßŸÑÿ∑ÿ®ŸÇÿßÿ™ ÿßŸÑŸÖÿ∑ÿßÿ®ŸÇÿ© ŸÅŸÇÿ∑
        allLayerGroups.forEach(({ group }) => {
          group.eachLayer(layer => {
            const props = layer.feature?.properties;
            const hasZoom = layer.getBounds || layer.getLatLng;

            let match = false;
            if (props) {
              for (const key in props) {
                const value = props[key];
                if (typeof value === "string" && normalizeText(value).includes(text)) {
                  match = true;
                  break;
                }
              }
            }

            if (match) {
              const name = props?.name?.trim() || `${layer._leaflet_id}`;
              if (hasZoom && !seenNames.has(name)) {
                matchedLayers.push(layer);
                seenNames.add(name);
              }
            }
          });
        });

        // 2. ÿ£ÿÆŸÅŸê ŸÉŸÑ ÿßŸÑÿ∑ÿ®ŸÇÿßÿ™
        allLayerGroups.forEach(({ group }) => {
          group.eachLayer(layer => {
            if (map.hasLayer(layer)) map.removeLayer(layer);
          });
        });

        // 3. ÿ£ÿ∏Ÿáÿ± ŸÅŸÇÿ∑ ÿßŸÑÿ∑ÿ®ŸÇÿßÿ™ ÿßŸÑŸÖÿ∑ÿßÿ®ŸÇÿ©
        matchedLayers.forEach(layer => {
          if (!map.hasLayer(layer)) {
            map.addLayer(layer);
          }
        });

        // 4. ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸàÿßÿ¨Ÿáÿ©
        matchCountSpan.textContent = matchedLayers.length;
        filterStatus.style.display = matchedLayers.length > 0 ? "flex" : "none";

        if (matchedLayers.length > 0) {
          currentMatchIndex = 0;
          zoomToMatch(currentMatchIndex);
        }
      }, 500);
    });

    clearFilterBtn.addEventListener("click", () => {
      filterInput.value = "";
      filterStatus.style.display = "none";
      matchedLayers = [];
      currentMatchIndex = -1;

      allLayerGroups.forEach(({ group }) => {
        group.eachLayer(layer => {
          if (!map.hasLayer(layer)) map.addLayer(layer);
        });
      });
    });

    function zoomToMatch(index) {
      const layer = matchedLayers[index];
      if (!layer) return;

      try {
        if (layer.getBounds) {
          map.fitBounds(layer.getBounds(), { maxZoom: 19 });
        } else if (layer.getLatLng) {
          map.setView(layer.getLatLng(), 17);
        }
      } catch (e) {
        console.warn("ÿ™ÿπÿ∞ÿ± ÿßŸÑÿ™ŸÉÿ®Ÿäÿ±:", e);
      }
    }

    nextBtn.addEventListener("click", () => {
      if (matchedLayers.length === 0) return;
      currentMatchIndex = (currentMatchIndex + 1) % matchedLayers.length;
      zoomToMatch(currentMatchIndex);
    });

    prevBtn.addEventListener("click", () => {
      if (matchedLayers.length === 0) return;
      currentMatchIndex = (currentMatchIndex - 1 + matchedLayers.length) % matchedLayers.length;
      zoomToMatch(currentMatchIndex);
    });
    
    document.addEventListener("click", function (e) {
      const target = e.target;
      if (target.matches("button[data-lat][data-lng][data-zoom]")) {

        const lat = parseFloat(target.getAttribute("data-lat"));
        const lng = parseFloat(target.getAttribute("data-lng"));
        const zoom = parseInt(target.getAttribute("data-zoom"));

        if (!isNaN(lat) && !isNaN(lng) && !isNaN(zoom)) {
          map.setView([lat, lng], zoom);
        }
      }
    });

  </script>
</body>

</html>