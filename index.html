<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="utf-8" />
  <title>ÿÆÿ±Ÿäÿ∑ÿ© ÿßŸÑŸÖÿ¥ÿßÿ±Ÿäÿπ ÿßŸÑÿßÿ≥ÿ™ÿ´ŸÖÿßÿ±Ÿäÿ©</title>
  <link href="https://fonts.googleapis.com/css2?family=Tajawal&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.control.layers.tree/L.Control.Layers.Tree.css" />
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div id="map-controls">
    <button id="toggleLayers" class="toggle-button" title="ÿ•ÿ∏Ÿáÿßÿ±/ÿ•ÿÆŸÅÿßÿ° ÿßŸÑÿ∑ÿ®ŸÇÿßÿ™">‚ò∞</button>
    <button class="basemap-button" onclick="setBaseMap('Map')">üó∫Ô∏è</button>
    <button class="basemap-button" onclick="setBaseMap('Esri')">üõ∞Ô∏è</button>
    <button class="basemap-button" onclick="setBaseMap('Gray')">‚¨ú</button>
    <input type="text" id="filterInput" placeholder="üîç ÿßŸÉÿ™ÿ® ŸÜÿµ ÿßŸÑŸÅŸÑÿ™ÿ±ÿ©" title="ÿßŸÉÿ™ÿ® ŸÑŸÑÿ®ÿ≠ÿ´ ÿØÿßÿÆŸÑ ÿßŸÑÿ∑ÿ®ŸÇÿßÿ™" />
    <button id="clearFilter" title="ŸÖÿ≥ÿ≠ ÿßŸÑŸÅŸÑÿ™ÿ±ÿ©">üßπ</button>
  </div>
</div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.control.layers.tree/L.Control.Layers.Tree.js"></script>
  <script>
    function normalizeText(text) {
      return text
      .toLowerCase()
      .replace(/[ÿ•ÿ£ÿ¢ÿß]/g, "ÿß")
      .replace(/Ÿâ/g, "Ÿä")
      .replace(/ÿ§/g, "Ÿà")
      .replace(/ÿ¶/g, "Ÿä")
      .replace(/ÿ©/g, "Ÿá")
      .replace(/[ŸãŸåŸçŸéŸèŸêŸíŸë]/g, "") // ÿ≠ÿ∞ŸÅ ÿßŸÑÿ™ÿ¥ŸÉŸäŸÑ
      .trim();
    }

    const map = L.map("map", { preferCanvas: true });
    const allLayerGroups = [];

    const baseMaps = {
    "Map": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'),
    "Esri": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'),
    "Gray": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}')
    };
    let currentBaseMap = baseMaps["Esri"];

    document.getElementById("toggleLayers").addEventListener("click", () => {
      const panel = document.querySelector(".leaflet-control-layers");
      if (panel) {
        panel.style.display = (panel.style.display === "none") ? "flex" : "none";
      }
    });

    function setBaseMap(name) {
      if (currentBaseMap) map.removeLayer(currentBaseMap);
      currentBaseMap = baseMaps[name];
      map.addLayer(currentBaseMap);
    }

    fetch("geojson_grouped.json")
      .then(res => res.json())
      .then(data => {
        const allBounds = L.latLngBounds();
        const treeGroups = [];

        for (let gid in data) {
          const group = data[gid];
          const groupName = group.__group_name__ || gid;
          const groupStyles = group.__styles__ || {};
          const children = [];

          for (let layerName in group) {
            if (layerName.startsWith("__")) continue;
            const fc = group[layerName];
            const style = groupStyles[layerName] || {};

            let mapLink = null;
            if (fc.features && fc.features.length > 0) {
              const props = fc.features[0].properties || {};
              if (typeof props.MapLink === "string") {
                const raw = props.MapLink.trim();
                const cleaned = raw.replace(/^["']|["']$/g, "");
                if (/^\d+\/-?\d+(\.\d+)?\/-?\d+(\.\d+)?$/.test(cleaned)) {
                  mapLink = cleaned;
                }
              }
            }

            const zoomCoords = mapLink ? mapLink.split("/") : null;
            const zoom = zoomCoords ? parseInt(zoomCoords[0]) : null;
            const lat = zoomCoords ? parseFloat(zoomCoords[1]) : null;
            const lng = zoomCoords ? parseFloat(zoomCoords[2]) : null;

            const jumpIcon = (zoom && lat && lng)
              ? `<span class='jump-icon' title='ÿßŸÑÿ∞Ÿáÿßÿ® ÿ•ŸÑŸâ ÿßŸÑŸÖŸàŸÇÿπ' data-zoom='${zoom}' data-lat='${lat}' data-lng='${lng}'>>></span>`
              : "";

            const labelHtml = `
              <span class='layer-color-box' style='background-color:${style.fillColor || style.color || "#3388ff"};opacity:${style.fillOpacity || 0.6};'></span>
              <span class='layer-name'>${layerName}</span>
              ${jumpIcon}
            `;

            const layerGroup = L.featureGroup();
            const geoJsonLayer = L.geoJSON(fc, {
              style: () => style,
              pointToLayer: (feature, latlng) => {
                const opts = {
                  radius: style.radius || 6,
                  fillColor: style.fillColor || style.color || "#3388ff",
                  color: style.color || "#333333",
                  weight: style.weight || 1,
                  fillOpacity: style.fillOpacity || 0.6
                };
                return L.circleMarker(latlng, opts);
              },
              onEachFeature: (feature, layerObj) => {
                const props = feature.properties || {};
                let rows = "";
                let rowsAdded = 0;
                const visible = props.__visible_fields__;

                if (Array.isArray(visible) && visible.length > 0) {
                  visible.forEach(f => {
                    const key = f.name;
                    const alias = f.alias || key;
                    const value = props[key];
                    if (value !== null && value !== undefined && value !== "") {
                      rows += `<tr><td class='popup-key'><b>${alias}</b></td><td class='popup-value'>${value}</td></tr>`;
                      rowsAdded++;
                    }
                  });
                } else {
                  for (let key in props) {
                    if (key.startsWith("__")) continue;
                    const value = props[key];
                    if (value !== null && value !== undefined && value !== "") {
                      rows += `<tr><td class='popup-key'><b>${key}</b></td><td class='popup-value'>${value}</td></tr>`;
                      rowsAdded++;
                    }
                  }
                }

                if (rowsAdded > 0) {
                  const popup = `<table class='popup-table'>${rows}</table>`;
                  layerObj.bindPopup(popup);
                }

                let markerLatLng = null;
                if (feature.geometry.type === "Point") {
                  markerLatLng = layerObj.getLatLng();
                } else {
                  try {
                    markerLatLng = layerObj.getBounds().getCenter();
                  } catch (e) {
                    markerLatLng = null;
                  }
                }

                if (markerLatLng) {
                  const icon = L.icon({
                    iconUrl: 'img/marker.png',
                    iconSize: [48, 48],
                    iconAnchor: [24, 48],
                    className: 'marker-with-shadow'
                  });
                  const marker = L.marker(markerLatLng, { icon });
                  marker.bindPopup(layerObj.getPopup());
                  marker.bindTooltip(layerName, {
                    permanent: false,
                    direction: 'top',
                    sticky: true,
                    className: 'marker-tooltip'
                  });
                  layerGroup.addLayer(marker);
                }

                layerGroup.addLayer(layerObj);
              }
            });

            layerGroup.addLayer(geoJsonLayer);
            layerGroup.addTo(map);
            const bounds = layerGroup.getBounds();
            if (bounds && bounds.isValid()) {
              allBounds.extend(bounds);
            }

            children.push({ label: labelHtml, layer: layerGroup });
            let keywords = normalizeText(layerName);

            if (fc.features && fc.features.length > 0) {
              fc.features.forEach(f => {
                const props = f.properties || {};
                for (let key in props) {
                  const val = props[key];
                  if (typeof val === "string") {
                    keywords += " " + normalizeText(val);
                  }
                }
              });
            }
            allLayerGroups.push({ keywords, group: layerGroup });
            }

            const groupLabel = `<b>${groupName} (${children.length})</b>`;

            treeGroups.push({
            label: groupLabel,
            selectAllCheckbox: true,
            children: children,
            collapsed: true
          });
        }

        if (allBounds.isValid()) {
          map.fitBounds(allBounds);
        } else {
        }

        if (!map.hasLayer(currentBaseMap)) {
          currentBaseMap.addTo(map);
        }

        const control = L.control.layers.tree(null, treeGroups, {
          collapsed: false,
          position: "topright"
        }).addTo(map);

        document.querySelector(".leaflet-control-layers").addEventListener("click", e => {
          const icon = e.target.closest(".jump-icon");
          if (icon) {
            e.preventDefault();
            e.stopPropagation();
            const zoom = parseInt(icon.dataset.zoom);
            const lat = parseFloat(icon.dataset.lat);
            const lng = parseFloat(icon.dataset.lng);
            if (!isNaN(zoom) && !isNaN(lat) && !isNaN(lng)) {
              map.setView([lat, lng], zoom);
            }
          }
        });
      });
      const filterInput = document.getElementById("filterInput");
      let filterTimeout = null;

filterInput.addEventListener("input", () => {
  clearTimeout(filterTimeout);
  filterTimeout = setTimeout(() => {
    const text = normalizeText(filterInput.value);

    allLayerGroups.forEach(({ keywords, group }) => {
      const match = keywords.includes(text);

      group.eachLayer(layer => {
        const el = layer.getElement?.();
        if (!el) return;

        el.classList.remove("layer-highlight", "layer-dimmed");
        if (text === "") return;

        if (match) {
          el.classList.add("layer-highlight");
        } else {
          el.classList.add("layer-dimmed");
        }
      });
    });
  }, 300);
});
  
document.getElementById("clearFilter").addEventListener("click", () => {
  filterInput.value = "";

  allLayerGroups.forEach(({ group }) => {
    if (!map.hasLayer(group)) map.addLayer(group);

    group.eachLayer(layer => {
      const el = layer.getElement?.();
      if (el) {
        el.classList.remove("layer-highlight", "layer-dimmed");
      }
    });
  });
});

  </script>
</body>
</html>
