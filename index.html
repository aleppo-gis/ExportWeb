<!DOCTYPE html>
<html lang="ar">

<head>
  <meta charset="utf-8" />
  <title>خريطة المشاريع الاستثمارية</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Tajawal&display=swap" >
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.control.layers.tree/L.Control.Layers.Tree.css" />
  <link rel="stylesheet" href="style/style.css" />
</head>

<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
  <div id="map-controls">
    <button id="toggleLayers" class="toggle-button" title="إظهار/إخفاء الطبقات"></button>
    <button class="basemap-button" data-basemap="Hybrid" title="قمر صناعي بمعلومات مكانية">🛰️</button>
    <button class="basemap-button" data-basemap="Satellite" title="قمر صناعي">🛰️</button>
    <button class="basemap-button" data-basemap="Road" title="خريطة بأسماء الشوارع">🗺️</button>
    <input type="text" id="filterInput" placeholder="🔍 اكتب نص الفلترة" title="اكتب للبحث داخل الطبقات" />
    <span id="filter-status" style="display: none;">
      <button id="match-count">0</button>
      <button id="prev-match" title="السابق">➡️</button>
      <button id="next-match" title="التالي">⬅️</button>
    </span>
    <button id="clearFilter" title="مسح الفلترة">❌</button>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.control.layers.tree/L.Control.Layers.Tree.js"></script>

  <script>
    let matchedLayers = [];
    let currentMatchIndex = -1;
    let filterTimeout = null;

    const filterInput = document.getElementById("filterInput");
    const clearFilterBtn = document.getElementById("clearFilter");
    const matchCountSpan = document.getElementById("match-count");
    const filterStatus = document.getElementById("filter-status");
    const nextBtn = document.getElementById("next-match");
    const prevBtn = document.getElementById("prev-match");

    const viewerPath = 'https://aleppo-gis.github.io/v/v.html';

    function compressGeoJSON(obj) {
      return LZString.compressToEncodedURIComponent(JSON.stringify(obj));
    }

    function findLayerByAlias(alias) {
      let found = null;
      if (!Array.isArray(allLayerGroups)) return null;
      allLayerGroups.forEach(({ group }) => {
        if (found) return;
        group.eachLayer(layer => {
          if (found) return;
          const feat = layer.feature || {};
          const props = feat.properties || {};
          const aliasName = props.Name || props.name || props['الاسم'] || layer.options?.name;
          if (aliasName === alias) found = layer;
        });
      });
      return found;
    }

    function extractPolygonCoordinates(layer) {
      if (typeof layer.getLatLngs === 'function') {
        const latlngsRaw = layer.getLatLngs();
        let ring = null;
        if (Array.isArray(latlngsRaw) && latlngsRaw.length) {
          if (Array.isArray(latlngsRaw[0]) && latlngsRaw[0][0] && typeof latlngsRaw[0][0].lat === 'number') ring = latlngsRaw[0];
          else if (latlngsRaw[0] && typeof latlngsRaw[0].lat === 'number') ring = latlngsRaw;
        }
        if (ring && ring.length >= 3) {
          const coords = ring.map(p => [p.lng, p.lat]);
          const first = coords[0], last = coords[coords.length - 1];
          if (!first || !last || first[0] !== last[0] || first[1] !== last[1]) coords.push([first[0], first[1]]);
          return coords;
        }
      }
      if (typeof layer.getLatLng === 'function') {
        const p = layer.getLatLng();
        const offset = 0.0008;
        return [
          [p.lng - offset, p.lat - offset],
          [p.lng + offset, p.lat - offset],
          [p.lng + offset, p.lat + offset],
          [p.lng - offset, p.lat + offset],
          [p.lng - offset, p.lat - offset]
        ];
      }
      return null;
    }

    function buildVisiblePropsOnly(layer) {
      const feat = layer.feature || {};
      const props = feat.properties || {};
      const visible = props.__visible_fields__;
      const result = {};

      if (Array.isArray(visible) && visible.length > 0) {
        visible.forEach(item => {
          if (!item || !item.name) return;
          const key = String(item.name);
          if (!(key in props)) return;
          const alias = (item.alias && String(item.alias)) || key;
          result[alias] = props[key];
        });
        return result;
      }

      Object.keys(props).forEach(k => {
        if (k.startsWith('_')) return;
        result[k] = props[k];
      });
      return result;
    }

    document.addEventListener('click', function (e) {
      const target = e.target;
      if (!target || target.id !== 'share') return;
      const layerAlias = target.dataset.layerName;
      if (!layerAlias) return;
      e.preventDefault();

      const layer = findLayerByAlias(layerAlias);
      if (!layer) { alert('لم يتم العثور على الطبقة'); return; }

      const coords = extractPolygonCoordinates(layer);
      if (!coords || coords.length < 4) { alert('تعذر استخراج مضلع صالح من الطبقة'); return; }

      const visibleProps = buildVisiblePropsOnly(layer);
      if (!visibleProps || Object.keys(visibleProps).length === 0) {
        visibleProps['الاسم'] = layerAlias;
      }

      const geojson = {
        type: 'FeatureCollection',
        features: [{
          type: 'Feature',
          geometry: { type: 'Polygon', coordinates: [coords] },
          properties: visibleProps
        }]
      };

      const compressed = compressGeoJSON(geojson);
      const shareUrl = viewerPath + '?data=' + encodeURIComponent(compressed);
      const message = `المشروع : ${layerAlias}\n${shareUrl}`;
      const whatsappUrl = 'https://wa.me/?text=' + encodeURIComponent(message);
      window.open(whatsappUrl, '_blank');
    });

    function normalizeText(text) {
      return text
        .toLowerCase()
        .replace(/[إأآا]/g, "ا")
        .replace(/ى/g, "ي")
        .replace(/ؤ/g, "و")
        .replace(/ئ/g, "ي")
        .replace(/ة/g, "ه")
        .replace(/[ًٌٍَُِّْ]/g, "")
        .trim();
    }

    const map = L.map("map", { preferCanvas: true });
    const allLayerGroups = [];

    const baseMaps = {
      "Hybrid": L.tileLayer('https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}'),
      "Satellite": L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}'),
      "Road": L.tileLayer('https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}')
    };
    let currentBaseMap = baseMaps["Hybrid"];

    document.getElementById("toggleLayers").addEventListener("click", () => {
      const panel = document.querySelector(".leaflet-control-layers");
      if (panel) {
        panel.style.display = (panel.style.display === "none") ? "flex" : "none";
      }
    });

    document.querySelectorAll('.basemap-button').forEach(button => {
      button.addEventListener('click', (e) => {
        const basemapType = e.target.dataset.basemap;
        if (basemapType && baseMaps[basemapType]) {
          setBaseMap(basemapType);
        }
      });
    });

    function setBaseMap(name) {
      if (currentBaseMap) map.removeLayer(currentBaseMap);
      currentBaseMap = baseMaps[name];
      map.addLayer(currentBaseMap);
    }

    fetch("data/geojson_grouped.json")
      .then(res => res.json())
      .then(data => {
        const allBounds = L.latLngBounds();
        const treeGroups = [];

        for (let gid in data) {
          const group = data[gid];
          const groupName = group.__group_name__ || gid;
          const groupStyles = group.__styles__ || {};
          const children = [];

          for (let layerName in group) {
            if (layerName.startsWith("__")) continue;
            const fc = group[layerName];
            const style = groupStyles[layerName] || {};

            let mapLink = null;
            if (fc.features && fc.features.length > 0) {
              const props = fc.features[0].properties || {};
              if (typeof props.MapLink === "string") {
                const raw = props.MapLink.trim();
                const cleaned = raw.replace(/^["']|["']$/g, "");
                if (/^\d+\/-?\d+(\.\d+)?\/-?\d+(\.\d+)?$/.test(cleaned)) {
                  mapLink = cleaned;
                }
              }
            }

            const zoomCoords = mapLink ? mapLink.split("/") : null;
            const zoom = zoomCoords ? parseInt(zoomCoords[0]) : null;
            const lat = zoomCoords ? parseFloat(zoomCoords[1]) : null;
            const lng = zoomCoords ? parseFloat(zoomCoords[2]) : null;

            const jumpIcon = (zoom && lat && lng) ? " 🎯" : "";
            const labelHtml = `
              <span class='layer-color-box' style='background-color:${style.fillColor || style.color || "#3388ff"}'></span>
              ${layerName}${jumpIcon}
              <button id='share' data-layer-name='${layerName}' style='margin-right: 5px; background: #25d366; color: white; border: none; padding: 2px 6px; border-radius: 3px; cursor: pointer;' title='مشاركة عبر واتساب'>📤</button>
            `;

            const layerGroup = L.geoJSON(fc, {
              style: function(feature) {
                return {
                  fillColor: style.fillColor || "#3388ff",
                  color: style.color || "#3388ff",
                  weight: style.weight || 2,
                  opacity: style.opacity || 1,
                  fillOpacity: style.fillOpacity || 0.2
                };
              },
              onEachFeature: function(feature, layer) {
                if (feature.properties) {
                  const props = feature.properties;
                  const visible = props.__visible_fields__ || [];
                  let popupContent = "<div style='direction: rtl; text-align: right;'>";
                  
                  if (visible.length > 0) {
                    visible.forEach(field => {
                      if (field.name && props[field.name] !== undefined) {
                        const alias = field.alias || field.name;
                        popupContent += `<b>${alias}:</b> ${props[field.name]}<br>`;
                      }
                    });
                  } else {
                    Object.keys(props).forEach(key => {
                      if (!key.startsWith('_')) {
                        popupContent += `<b>${key}:</b> ${props[key]}<br>`;
                      }
                    });
                  }
                  
                  popupContent += "</div>";
                  layer.bindPopup(popupContent);
                }
                
                allBounds.extend(layer.getBounds());
              }
            });

            children.push({
              label: labelHtml,
              layer: layerGroup
            });

            allLayerGroups.push({ name: layerName, group: layerGroup });
          }

          if (children.length > 0) {
            treeGroups.push({
              label: groupName,
              children: children
            });
          }
        }

        const layersControl = L.control.layers.tree(null, treeGroups, {
          namedToggle: false,
          selectorBack: false,
          closedSymbol: '▶',
          openedSymbol: '▼',
          spaceSymbol: ' ',
          collapsed: false
        });

        layersControl.addTo(map);
        
        if (allBounds.isValid()) {
          map.fitBounds(allBounds, { padding: [20, 20] });
        } else {
          map.setView([36.2021, 37.1343], 10);
        }

        setBaseMap("Hybrid");

        function performFilter() {
          const query = filterInput.value.trim();
          if (!query) {
            clearFilter();
            return;
          }

          const normalizedQuery = normalizeText(query);
          matchedLayers = [];

          allLayerGroups.forEach(({ name, group }) => {
            group.eachLayer(layer => {
              const feature = layer.feature;
              if (!feature || !feature.properties) return;

              const props = feature.properties;
              const visible = props.__visible_fields__ || [];
              let searchText = "";

              if (visible.length > 0) {
                visible.forEach(field => {
                  if (field.name && props[field.name]) {
                    searchText += " " + String(props[field.name]);
                  }
                });
              } else {
                Object.keys(props).forEach(key => {
                  if (!key.startsWith('_') && props[key]) {
                    searchText += " " + String(props[key]);
                  }
                });
              }

              if (normalizeText(searchText).includes(normalizedQuery)) {
                matchedLayers.push(layer);
              }
            });
          });

          updateFilterStatus();
          if (matchedLayers.length > 0) {
            currentMatchIndex = 0;
            highlightCurrentMatch();
          }
        }

        function clearFilter() {
          matchedLayers = [];
          currentMatchIndex = -1;
          filterInput.value = "";
          filterStatus.style.display = "none";
          
          allLayerGroups.forEach(({ group }) => {
            group.eachLayer(layer => {
              layer.setStyle({ opacity: 1, fillOpacity: 0.2 });
            });
          });
        }

        function updateFilterStatus() {
          if (matchedLayers.length > 0) {
            filterStatus.style.display = "inline";
            matchCountSpan.textContent = matchedLayers.length;
          } else {
            filterStatus.style.display = "none";
          }
        }

        function highlightCurrentMatch() {
          if (matchedLayers.length === 0) return;

          allLayerGroups.forEach(({ group }) => {
            group.eachLayer(layer => {
              layer.setStyle({ opacity: 0.3, fillOpacity: 0.1 });
            });
          });

          const currentLayer = matchedLayers[currentMatchIndex];
          currentLayer.setStyle({ opacity: 1, fillOpacity: 0.6 });
          map.fitBounds(currentLayer.getBounds(), { padding: [50, 50] });
        }

        filterInput.addEventListener("input", () => {
          clearTimeout(filterTimeout);
          filterTimeout = setTimeout(performFilter, 300);
        });

        clearFilterBtn.addEventListener("click", clearFilter);

        nextBtn.addEventListener("click", () => {
          if (matchedLayers.length > 0) {
            currentMatchIndex = (currentMatchIndex + 1) % matchedLayers.length;
            highlightCurrentMatch();
          }
        });

        prevBtn.addEventListener("click", () => {
          if (matchedLayers.length > 0) {
            currentMatchIndex = (currentMatchIndex - 1 + matchedLayers.length) % matchedLayers.length;
            highlightCurrentMatch();
          }
        });
      })
      .catch(error => {
        console.error('خطأ في تحميل البيانات:', error);
        alert('فشل في تحميل بيانات الخريطة');
      });
  </script>
</body>
</html>