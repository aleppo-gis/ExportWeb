<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="utf-8" />
  <title>ÿÆÿ±Ÿäÿ∑ÿ© ÿßŸÑŸÖÿ¥ÿßÿ±Ÿäÿπ ÿßŸÑÿßÿ≥ÿ™ÿ´ŸÖÿßÿ±Ÿäÿ©</title>
  <link href="https://fonts.googleapis.com/css2?family=Tajawal&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.control.layers.tree/L.Control.Layers.Tree.css" />
  <link rel="stylesheet" href="style.css">
</head>
<body>
<div id="map-controls" style="direction: rtl;">
  <button id="toggleLayers" class="toggle-button" title="ÿ•ÿ∏Ÿáÿßÿ±/ÿ•ÿÆŸÅÿßÿ° ÿßŸÑÿ∑ÿ®ŸÇÿßÿ™">‚ò∞</button>
  <button class="basemap-button" onclick="setBaseMap('Map')">üó∫Ô∏è</button>
  <button class="basemap-button" onclick="setBaseMap('Esri')">üõ∞Ô∏è</button>
</div>

  <div id="map"></div>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.control.layers.tree/L.Control.Layers.Tree.js"></script>
  <script>
    const map = L.map("map");
    const allBounds = L.latLngBounds();
    const treeGroups = [];

    L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: "¬© OpenStreetMap"
    }).addTo(map);

    fetch("geojson_grouped.json")
      .then(res => res.json())
      .then(data => {
        for (let gid in data) {
          const group = data[gid];
          const groupName = group.__group_name__ || gid;
          const groupStyles = group.__styles__ || {};
          const children = [];

          for (let layerName in group) {
            if (layerName.startsWith("__")) continue;
            const fc = group[layerName];
            const style = groupStyles[layerName] || {};

            let mapLink = null;
            if (fc.features && fc.features.length > 0) {
              const props = fc.features[0].properties || {};
              if (typeof props.MapLink === "string") {
                const raw = props.MapLink.trim();
                const cleaned = raw.replace(/^["']|["']$/g, "");
                if (/^\d+\/-?\d+(\.\d+)?\/-?\d+(\.\d+)?$/.test(cleaned)) {
                  mapLink = cleaned;
                }
              }
            }

            const zoomCoords = mapLink ? mapLink.split("/") : null;
            const zoom = zoomCoords ? parseInt(zoomCoords[0]) : null;
            const lat = zoomCoords ? parseFloat(zoomCoords[1]) : null;
            const lng = zoomCoords ? parseFloat(zoomCoords[2]) : null;

            const jumpIcon = (zoom && lat && lng)
              ? `<span class='jump-icon' title='ÿßŸÑÿ∞Ÿáÿßÿ® ÿ•ŸÑŸâ ÿßŸÑŸÖŸàŸÇÿπ' data-zoom='${zoom}' data-lat='${lat}' data-lng='${lng}'>>></span>`
              : "";

            const labelHtml = `
              <span class='layer-color-box' style='background-color:${style.fillColor || style.color || "#3388ff"};opacity:${style.fillOpacity || 0.6};'></span>
              <span class='layer-name'>${layerName}</span>
              ${jumpIcon}
            `;

            const layer = L.geoJSON(fc, {
              style: () => style,
              pointToLayer: (feature, latlng) => {
                const opts = {
                  radius: style.radius || 6,
                  fillColor: style.fillColor || style.color || "#3388ff",
                  color: style.color || "#333333",
                  weight: style.weight || 1,
                  fillOpacity: style.fillOpacity || 0.6
                };
                return L.circleMarker(latlng, opts);
              },
              onEachFeature: (feature, layerObj) => {
                const props = feature.properties || {};
                let rows = "";
                let rowsAdded = 0;
                const visible = props.__visible_fields__;

                if (Array.isArray(visible) && visible.length > 0) {
                  visible.forEach(f => {
                    const key = f.name;
                    const alias = f.alias || key;
                    const value = props[key];
                    if (value !== null && value !== undefined && value !== "") {
                      rows += `<tr><td class='popup-key'><b>${alias}</b></td><td class='popup-value'>${value}</td></tr>`;
                      rowsAdded++;
                    }
                  });
                } else {
                  for (let key in props) {
                    if (key.startsWith("__")) continue;
                    const value = props[key];
                    if (value !== null && value !== undefined && value !== "") {
                      rows += `<tr><td class='popup-key'><b>${key}</b></td><td class='popup-value'>${value}</td></tr>`;
                      rowsAdded++;
                    }
                  }
                }

                if (rowsAdded > 0) {
                  const popup = `<table class='popup-table'>${rows}</table>`;
                  layerObj.bindPopup(popup);
                }
                let markerLatLng = null;
                if (feature.geometry.type === "Point") {
                  markerLatLng = layerObj.getLatLng();
                } else {
                  try {
                    markerLatLng = layerObj.getBounds().getCenter();
                  } catch (e) {
                    markerLatLng = null;
                  }
                }

                if (markerLatLng) {
                  const icon = L.icon({
                    iconUrl: 'img/marker.png',
                    iconSize: [32, 32],
                    iconAnchor: [16, 32],
                    className: 'marker-with-shadow'
                  });
                  const marker = L.marker(markerLatLng, { icon }).addTo(map);
                  marker.bindPopup(layerObj.getPopup());
                  marker.bindTooltip(layerName, {
                    permanent: false,
                    direction: 'top',
                    sticky: true,
                    className: 'marker-tooltip'
                  });
                }
              }
            });

            layer.addTo(map);
            try { allBounds.extend(layer.getBounds()); } catch (e) {}

            children.push({ label: labelHtml, layer: layer });
          }

          treeGroups.push({
            label: `<b>${groupName}</b>`,
            selectAllCheckbox: true,
            children: children,
            collapsed: true
          });
        }

        setTimeout(() => {
          if (allBounds.isValid && allBounds.isValid()) {
            map.fitBounds(allBounds);
          }

          const control = L.control.layers.tree(null, treeGroups, {
            collapsed: false,
            position: "topright"
          }).addTo(map);
        }, 1000);

        setTimeout(() => {
          document.querySelector(".leaflet-control-layers").addEventListener("click", e => {
            const icon = e.target.closest(".jump-icon");
            if (icon) {
              e.preventDefault();
              e.stopPropagation();
              const zoom = parseInt(icon.dataset.zoom);
              const lat = parseFloat(icon.dataset.lat);
              const lng = parseFloat(icon.dataset.lng);
              if (!isNaN(zoom) && !isNaN(lat) && !isNaN(lng)) {
                map.setView([lat, lng], zoom);
              }
            }
          });
        }, 1500);
      });

    document.getElementById("toggleLayers").addEventListener("click", () => {
      const panel = document.querySelector(".leaflet-control-layers");
      if (panel) {
        panel.style.display = (panel.style.display === "none") ? "flex" : "none";
      }
    });
    let currentBaseMap = baseMaps["ÿÆÿ±Ÿäÿ∑ÿ© ÿπÿßÿØŸäÿ©"];
    function setBaseMap(name) {
    if (currentBaseMap) {
      map.removeLayer(currentBaseMap);
    }
    currentBaseMap = baseMaps[name];
    map.addLayer(currentBaseMap);
    }
  </script>
</body>
</html>
